import type {
  AppData,
  BaseLoan,
  ComputedLoan,
  Grant,
  PortfolioSummary,
  RefinanceEvent,
  UpcomingEvent,
} from './types'

// ---------------------------------------------------------------------------
// Interest compounding
// ---------------------------------------------------------------------------

/**
 * For a given base loan, compute all interest loans generated by annual
 * compounding from (grantYear + 1) through the year the loan is due.
 *
 * Each year's interest = baseLoan.amount * baseLoan.rate.
 * The resulting interest loan is issued at that year's Epic rate.
 */
export function computeInterestLoans(
  baseLoan: BaseLoan,
  ratesByYear: AppData['ratesByYear'],
): ComputedLoan[] {
  const rateMap = new Map(ratesByYear.map((r) => [r.year, r.rate]))
  const dueYear = new Date(baseLoan.due).getFullYear()
  const results: ComputedLoan[] = []

  for (let year = baseLoan.grantYear + 1; year <= dueYear; year++) {
    const interestAmount = baseLoan.amount * baseLoan.rate
    const issuedRate = rateMap.get(year) ?? baseLoan.rate // fallback to same rate if unknown

    results.push({
      id: `${baseLoan.id}-interest-${year}`,
      label: `${baseLoan.grantYear} ${baseLoan.grantType} Interest (${year})`,
      grantYear: baseLoan.grantYear,
      grantType: baseLoan.grantType,
      loanType: baseLoan.loanType,
      originYear: year,
      amount: interestAmount,
      rate: issuedRate,
      due: baseLoan.due,
      kind: 'interest',
      superseded: false,
      sourceBaseLoanId: baseLoan.id,
    })
  }

  return results
}

/**
 * Build the full list of ComputedLoans from AppData:
 * 1. Convert each BaseLoan to a ComputedLoan
 * 2. For each BaseLoan, generate interest loans per year
 * 3. Apply RefinanceEvents: mark replaced loans as superseded, add replacements
 */
export function computeAllLoans(data: AppData): ComputedLoan[] {
  const loans: ComputedLoan[] = []

  // Step 1 & 2: base loans + their compounded interest loans
  for (const bl of data.baseLoans) {
    loans.push({
      id: bl.id,
      label: `${bl.grantYear} ${bl.grantType} ${bl.loanType}`,
      grantYear: bl.grantYear,
      grantType: bl.grantType,
      loanType: bl.loanType,
      originYear: bl.grantYear,
      amount: bl.amount,
      rate: bl.rate,
      due: bl.due,
      kind: 'base',
      superseded: false,
    })

    const interestLoans = computeInterestLoans(bl, data.ratesByYear)
    loans.push(...interestLoans)
  }

  // Step 3: apply refinance events
  const supersededIds = new Set<string>()
  for (const re of data.refinanceEvents) {
    re.replacesLoanIds.forEach((id) => supersededIds.add(id))
  }

  // Mark superseded base loans
  for (const loan of loans) {
    if (supersededIds.has(loan.id)) {
      loan.superseded = true
    }
  }

  // Add refinance replacement loans
  for (const re of data.refinanceEvents) {
    const replaced = loans.filter((l) => re.replacesLoanIds.includes(l.id))
    if (replaced.length === 0) continue

    // Sum up the principals being replaced to determine new loan amount
    const newAmount = replaced.reduce((sum, l) => sum + l.amount, 0)
    const representative = replaced[0]!

    loans.push({
      id: `refinance-${re.id}`,
      label: `Refinanced ${new Date(re.date).getFullYear()} (replaces ${re.replacesLoanIds.length} loan${re.replacesLoanIds.length > 1 ? 's' : ''})`,
      grantYear: representative.grantYear,
      grantType: representative.grantType,
      loanType: representative.loanType,
      originYear: new Date(re.date).getFullYear(),
      amount: newAmount,
      rate: re.newRate,
      due: re.newDue,
      kind: 'refinance-replacement',
      superseded: false,
      refinanceEventId: re.id,
    })
  }

  // Stable sort: by grantYear ASC, then originYear ASC
  loans.sort((a, b) =>
    a.grantYear !== b.grantYear
      ? a.grantYear - b.grantYear
      : a.originYear - b.originYear,
  )

  return loans
}

// ---------------------------------------------------------------------------
// Portfolio summary
// ---------------------------------------------------------------------------

export function computeCurrentShares(data: AppData): number {
  return data.shareEvents.reduce((sum, e) => sum + e.vestedDelta, 0)
}

export function computeVestedShares(data: AppData, asOf = new Date()): number {
  return data.grants.reduce((total, grant) => {
    const vestStart = new Date(grant.vestStart)
    const monthsPerPeriod = 12 // annual vesting assumed; adjust if needed
    let vested = 0
    for (let i = 0; i < grant.vestPeriods; i++) {
      const vestDate = new Date(vestStart)
      vestDate.setMonth(vestDate.getMonth() + i * monthsPerPeriod)
      if (vestDate <= asOf) {
        vested += grant.shares / grant.vestPeriods
      }
    }
    return total + vested
  }, 0)
}

export function computeTotalLoanBalance(loans: ComputedLoan[]): number {
  return loans
    .filter((l) => !l.superseded)
    .reduce((sum, l) => sum + l.amount, 0)
}

export function computeAccruedInterest(
  loans: ComputedLoan[],
  asOf = new Date(),
): number {
  return loans
    .filter((l) => !l.superseded)
    .reduce((sum, loan) => {
      const dueDate = new Date(loan.due)
      if (asOf >= dueDate) return sum
      const yearFraction =
        (asOf.getTime() - new Date(loan.originYear, 0, 1).getTime()) /
        (365.25 * 24 * 60 * 60 * 1000)
      return sum + loan.amount * loan.rate * Math.max(0, yearFraction)
    }, 0)
}

export function computePortfolioSummary(
  data: AppData,
  loans: ComputedLoan[],
  asOf = new Date(),
): PortfolioSummary {
  const currentShares = computeCurrentShares(data)
  const vestedShares = computeVestedShares(data, asOf)
  const totalGrants = data.grants.reduce((s, g) => s + g.shares, 0)
  const portfolioValue = currentShares * data.currentPrice
  const totalLoanBalance = computeTotalLoanBalance(loans)
  const totalAccruedInterest = computeAccruedInterest(loans, asOf)

  return {
    currentShares,
    portfolioValue,
    totalLoanBalance,
    netValue: portfolioValue - totalLoanBalance,
    totalAccruedInterest,
    vestedShares,
    unvestedShares: Math.max(0, totalGrants - vestedShares),
  }
}

// ---------------------------------------------------------------------------
// Upcoming events
// ---------------------------------------------------------------------------

/** Returns events occurring within [today, today + windowDays] */
export function getUpcomingEvents(
  data: AppData,
  today = new Date(),
  windowDays = 7,
): UpcomingEvent[] {
  const windowEnd = new Date(today)
  windowEnd.setDate(windowEnd.getDate() + windowDays)

  const events: UpcomingEvent[] = []

  // Vesting dates
  for (const grant of data.grants) {
    const vestStart = new Date(grant.vestStart)
    for (let i = 0; i < grant.vestPeriods; i++) {
      const vestDate = new Date(vestStart)
      vestDate.setFullYear(vestStart.getFullYear() + i) // annual vesting
      if (vestDate >= today && vestDate <= windowEnd) {
        events.push({
          date: vestDate.toISOString().split('T')[0]!,
          label: `${grant.year} ${grant.type} â€” vesting period ${i + 1}`,
          type: 'vesting',
        })
      }
    }
  }

  // Loan due dates
  for (const loan of data.baseLoans) {
    const due = new Date(loan.due)
    if (due >= today && due <= windowEnd) {
      events.push({
        date: loan.due,
        label: `${loan.grantYear} ${loan.grantType} ${loan.loanType} loan due`,
        type: 'loan-due',
      })
    }
  }

  // Interest compounding dates (July 15 each year by convention)
  const compoundMonth = 6 // July (0-indexed)
  const compoundDay = 15
  for (let y = today.getFullYear(); y <= windowEnd.getFullYear(); y++) {
    const compoundDate = new Date(y, compoundMonth, compoundDay)
    if (compoundDate >= today && compoundDate <= windowEnd) {
      events.push({
        date: compoundDate.toISOString().split('T')[0]!,
        label: 'Annual interest compounding date',
        type: 'interest-compound',
      })
    }
  }

  // Refinance events
  for (const re of data.refinanceEvents) {
    const d = new Date(re.date)
    if (d >= today && d <= windowEnd) {
      events.push({
        date: re.date,
        label: `Refinance event (${re.replacesLoanIds.length} loans)`,
        type: 'refinance',
      })
    }
  }

  events.sort((a, b) => a.date.localeCompare(b.date))
  return events
}

// ---------------------------------------------------------------------------
// Chart helpers
// ---------------------------------------------------------------------------

export interface LoanChartRow {
  name: string
  balance: number
  interest: number
}

export function buildLoanChartData(loans: ComputedLoan[]): LoanChartRow[] {
  const active = loans.filter((l) => !l.superseded)
  const byGrant = new Map<string, { balance: number; interest: number }>()

  for (const loan of active) {
    const key = `${loan.grantYear} ${loan.grantType}`
    const existing = byGrant.get(key) ?? { balance: 0, interest: 0 }
    if (loan.kind === 'base') {
      existing.balance += loan.amount
    } else {
      existing.interest += loan.amount
    }
    byGrant.set(key, existing)
  }

  return Array.from(byGrant.entries())
    .map(([name, { balance, interest }]) => ({ name, balance, interest }))
    .sort((a, b) => a.name.localeCompare(b.name))
}

export interface VestingChartRow {
  year: number
  vestedShares: number
  unvestedShares: number
}

export function buildVestingChartData(
  grants: Grant[],
  currentYear = new Date().getFullYear(),
): VestingChartRow[] {
  const years = new Set<number>()
  for (const g of grants) {
    for (let i = 0; i < g.vestPeriods; i++) {
      years.add(new Date(g.vestStart).getFullYear() + i)
    }
  }

  return Array.from(years)
    .sort()
    .map((year) => {
      const asOf = new Date(year, 11, 31)
      let vestedShares = 0
      let unvestedShares = 0
      for (const g of grants) {
        const vestStart = new Date(g.vestStart)
        for (let i = 0; i < g.vestPeriods; i++) {
          const vestDate = new Date(vestStart)
          vestDate.setFullYear(vestStart.getFullYear() + i)
          const sharesThisPeriod = g.shares / g.vestPeriods
          if (vestDate <= asOf) {
            vestedShares += sharesThisPeriod
          } else if (vestDate.getFullYear() > currentYear) {
            unvestedShares += sharesThisPeriod
          }
        }
      }
      return { year, vestedShares, unvestedShares }
    })
}

// ---------------------------------------------------------------------------
// Schema migration
// ---------------------------------------------------------------------------

export const CURRENT_SCHEMA_VERSION = 1

export function migrateAppData(raw: unknown): AppData {
  // Currently only version 1 exists; future migrations added here
  const data = raw as AppData
  if (!data.schemaVersion) {
    data.schemaVersion = 1
  }
  return data
}

// ---------------------------------------------------------------------------
// Empty state
// ---------------------------------------------------------------------------

export function emptyAppData(): AppData {
  return {
    schemaVersion: CURRENT_SCHEMA_VERSION,
    currentPrice: 0,
    asOfDate: new Date().toISOString().split('T')[0]!,
    grants: [],
    baseLoans: [],
    ratesByYear: [],
    refinanceEvents: [],
    shareEvents: [],
    priceHistory: [],
  }
}

export function formatCurrency(value: number): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(value)
}

export function formatPercent(rate: number): string {
  return `${(rate * 100).toFixed(2)}%`
}

export function formatDate(iso: string): string {
  return new Date(iso).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    timeZone: 'UTC',
  })
}

// Refinance helpers
export function getRefinanceForLoan(
  loanId: string,
  refinanceEvents: RefinanceEvent[],
): RefinanceEvent | undefined {
  return refinanceEvents.find((re) => re.replacesLoanIds.includes(loanId))
}
